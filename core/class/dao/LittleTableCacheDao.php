<?php
/**
 * 用来解决表里数据过少,但是又要持续缓存过多的问题,因为大量的表是通过某个唯一的字段unique_key进行查询的
 * 主要是用来直接判断主key查询是否存在
 * 如果你表已经存在,且已经有数据,需要调用 InitLittleTableCache 这个job 进行数据初始化操作
 * 使用这个cache必须使用redis,因为redis可以恢复数据,如果redis挂掉,可能会出现数据不一致的情况,所以必须
 * 有个脚本可以实时的去统计这个数据
 * 切记不能通过其他程序操作这个表,更新查询都可以,不能写入
 * 使用场景必须满足一下几个条件
 * 1.表数据不要超过100w
 * 2.表的写入不能太频繁,比如每秒几百个,虽然这样不会出什么问题,但是如果redis挂掉,数据就很难同步上来,会出现异常
 * 3.比如有一个主查询字段,类似unique_key,如果没有这种字段,使用这个cache也没什么意义,注意迁移机房的问题
 * Class LittleTableCacheDao
 * @package Dao
 * Created by PhpStorm.
 * User: kirk
 * Date: 18-7-5
 * Time: 下午7:54
 */

abstract class LittleTableCacheDao extends \Dao_CacheDao {
    private $cache = null;
    public function get_cache(){
        if(!$this->cache) {
            return new \RedisCache();
        }
        return $this->cache;
    }
    /**
     * 关键词key,
     * @return string
     */
    abstract public function get_main_search_key();

    public function get_little_search_key_pre(){
        return $this->get_table_name().'_little_key_';
    }
    public function get_by_where($where,$order='',$limit='0,2000',$fileds = '*'){
        if ($this->check_go_parent($where)) {
            return parent::get_by_where($where, $order, $limit, $fileds);
        } else {
            return [];
        }
    }
    public function check_go_parent($where) {

        $cache = \KIRK::get_instance()->get_config('cache');
        if(!$cache) {
            return true;
        }

        if($key_value = $where[$this->get_main_search_key()]) {
            \KIRK::get_instance()->debug('命中查询key', 'littletablecache');
            $cache = $this->get_cache();

            \KIRK::get_instance()->debug($this->get_little_search_key_pre() . $key_value,'littletablecache');
            if ($cache->get($this->get_little_search_key_pre() . $key_value)) {
                \KIRK::get_instance()->debug('有数据,进入parent', 'littletablecache');
                return true;
            } else {
                \KIRK::get_instance()->debug('没有有数据,不进入parent', 'littletablecache');
                return false;
            }
        } else {
            return true;
        }
    }
    public function get_single_by_where($where, $order = '', $fields = '*') {
        if ($this->check_go_parent($where)) {
            return parent::get_single_by_where($where,$order,$fields);
        } else {
            return false;
        }
    }
    public function get_count_by_where($where) {
        if ($this->check_go_parent($where)) {
            return parent::get_count_by_where($where);
        } else {
            return 0;
        }
    }
    public function insert($data) {
        if($key_value  = $data[$this->get_main_search_key()]) {
            $cache = $this->get_cache();
            $cache->set($this->get_little_search_key_pre() . $key_value,1);
        }
        return parent::insert($data); // TODO: Change the autogenerated stub
    }
}
